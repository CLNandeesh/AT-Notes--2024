->Non Functional testing
	Performance testing

->Bottleneck
Defects are referred as Bottleneck in PT
Cause for the deviation in the requirement.
Ex: Login should take 2sec but its taking 6 sec. The reason for this slowness is the Bottleneck.

->Why Perf testing
To maintain quality of the Application , make sure application runs faster.
As load[# users] increases on the AUT, Perf of the application may deteriorates.

->NFR
Non functional requirements to perform Perf Testing

->What is Perf Testing
Concurrent users: # users using application at same point of time
Applying load on AUT and check the behaviour of the application wrt response time.
# users count will be given by client as part of NFR
These users are called Vusers: Machine generated users

->PT Tools
Load Runner
Performance center
Jmeter
NewLoad
SilkPerformer
Webload
OATS

->Types of Users
User base: Total number of users who can access the Application
Application Users/Concurrent Users: Total number of users using[transaction or think time] system at specific point of time. 
Simultaneous users:  Total number of users performing same operation at specific point of time. 

Ex:
UB:100 Users
CU:20 using login/10 using payment/10 Waiting/25 Searching the product = 70 users using the application 
SU:25 Searching the product at same time 

->Install Load Runner
Mercury came out Load runner from 1993 till 2016, now acquired by HP at 2004, Micro focus acquired from HP 
Install Load runner
 Vugen
 Controller
 Analysis

->Software Architecture
Hw+Sw
To identify the reason for bottleneck, we need to aware of the architecture.

->Server
Processor+Memory[RAM]+Harddisk
Software which understand and process the client request
Place where our application is hosted

File server: Process request related to files 
Database Server: Process request related to data
Application Server[App server]: Process request related to the application. Ex: Need to login to FB, Need to delete post in twitter.

Presentation layer[UI]
Business layer[Backend]
Data layer[DB]

Desktop App: Thin client [2 Tier Arch/Client Server]
Web App: Thick client [2 Tier Arch/Client Server]

3 Tier Arch [UI Layer+ Business logic Layer[App Server]+Data Layer] All 3 in different machine

Web Application N Tier Architecture:
it can have any number of app servers
Client<->Webserver<->App Server<->DB Server

->Transaction
Each request sent from Client to Server
Any request sent to Server is known as transaction
Note: UI level actions are not transaction, ex: entering UN is not transaction. Enter un,pw and Click on Login button , a request is sent to Server to perform login this is considered as Transaction
Ex: Launch Page transaction, Login transaction, Logout Transaction

->Response Time or E to E Transaction response time
Time taken for the complete request to be processed by Server and sends back response to Client.
Client---request->Server
Server--response-->Client 

->Internet: between client and server
  Intranet: between web, app and db server

->Request processing
If App server takes more time to process the request then we may need to increase the count of App server. [Scale Up]
Inc App/Web server/ DB server count: Scale up
Dec App/Web server/ DB server count: Scale down

Client/1 to N Web server/1 to N App server/1 to N DB server

->Difference between Web server and App server
Client send request to Web server, if the request is for static content then Web server responds to it, if request has business logic or any dynamic content then it sends to App server to process the request.

Key Differences

Purpose:
Web Server: Primarily serves static content and handles HTTP requests.
Application Server: Executes business logic and serves dynamic content, providing additional services for enterprise applications.
Content Served:
Web Server: Static content (HTML, CSS, images).
Application Server: Dynamic content generated by server-side applications.

Services Provided:
Web Server: Basic request handling and load balancing.
Application Server: Advanced services like transaction management, messaging, and middleware integration.

Examples:
Web Server: Apache HTTP Server, Nginx, IIS.
Application Server: Apache Tomcat, JBoss (WildFly), IBM WebSphere, Oracle WebLogic.

Conclusion
While both web servers and application servers are crucial components of web infrastructure, they serve different purposes. A web server focuses on delivering static content quickly and efficiently, whereas an application server is designed to execute complex business logic and generate dynamic content. In many modern architectures, these roles can overlap, with servers like Apache Tomcat acting as both a web server and an application server.


->Load balancing

c1   L  WS1    AS1
     O
c2   A                       DB Server
     D  WS2
c3
     B         AS2
.    A
.    L
.    A  WS3
     N
     C
     E
     R
LB checks which server is free and has less load and allocate request to that specific server to handles the request.

->Three tier architecture

Client<-->WebApp Servers[Tomcat,JBoss,Weblogic,Websphere,IS..]<-->DB Server

->User load
New App: Client specify
Old App: Splunk logs

->Host machine: Where WebApp server[Tomcat,JBoss,...] / DB server [Oracle, DB2,..]is installed.Both can be in single host machine or it can in different host machine.
One HM has WebApp server and other HM has DB server.
OS:Redhat Linux, Solaris, HP-UX,...

->Performance tuning
Client-internet time->WebApp Server--intranet time->DB Server
                        5 sec to                      20 sec to 
                    process request                process request
                   |---------Response time--------------------|

Time taken can be in WebApp server or Db server, need to check on these two if there is more response time

Performance Tuning: Fixing bottle neck either in WebApp server or Db server or in whole system.

->Protocol
Set of rules to be followed by client to connect with server.
http/https/ftp/smtp/,...





       