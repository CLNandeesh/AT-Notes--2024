Java Content
============
Variables and Data Types
Identifiers
Type Casting
Operator
Conditional Statements
Iterative Statements
Switch Statement
Number system
Naming Convention
Class and Object
JVM Memory
Methods
this keyword
Scanner Class
OO Programming Features
   Polymorphism[Overloading]
   Encapsulation
Constructor
Static keyword
Inheritance
Polymorphism[Overriding]
Access Modifiers


*****************************************************************************************************************************************************
Variables and Data Types
========================
->To Store data we use variables and to specify what type of data we are storing in the variables then we need to use Data types. 
->It is used for memory allocation. 

Types of Variables
------------------
Instance variable
->Declared outside method, block, constructor and inside the class.
->Has default value
->Can be accessed using reference variable

Local variable
->Declared inside method, block, constructor, loop.
->Not have default value, should be initialized before use.

Static variable
->Declared outside method, block, constructor and inside the class with keyword static.
->Has default value
->Can be accessed using reference variable and class name

*****************************************************************************************************************************************************
Primitive Data type
-------------------
->-2^(n-1) to 2^(n-1) -1
->If exceeds the range then Compiler will throw an error.
->Default data type for whole number, Java consider is int, If we are performing any operation on 2 or more numbers then the result data is by default is int data type.
->Default data type for float number, Java consider is double, If we are performing any operation on 2 or more numbers then the result data is by default is double data type.
->Bases on UTF, Unicode representation above memory representation.

byte
1 byte of memory is allocated
Default Value: 0
Ex:
byte b=22;

short
2 byte of memory is allocated
Default Value: 0
Ex:
short s=33;

char
2 bytes of memory is allocated
Ex: 
char c='A'; //A
char c=65; //A

int
4 bytes of memory is allocated
Default Value: 0
Ex:
int i=345;

long
8 bytes of memory is allocated
Default Value: 0
Ex: 
long l=3456l;
long l=12345L;

float
4 bytes of memory is allocated
Default Value: 0.0
7 digit precession
Ex:
float f=12.3f;
float f=23.44F;

double
8 bytes of memory is allocated
Default Value: 0.0
14 digit precession
Ex:
double f=12.3;
double f=23.44;

Boolean
1 bit of memory is allocated
Default Value: false
Ex:
Boolean

*****************************************************************************************************************************************************
Identifiers
===========
->Start with letters, _ and $
->Can contains letters, digits. _ and $
->No use of Keyword or Reserve words
->Give meaningful names

*****************************************************************************************************************************************************
Type Casting
============
->Converting data of one type to another type.
->Types
Implicit: Lower to Higher implicitly by JVM
Ex:
byte b=10;
int i=b;

Explicit: Higher to Lower explicitly by developer using cast operator
Ex:
int i=10;
byte b=(byte) i;

->Type checking: Compiler
  Type Casting: JVM

Type casting chart
byte->short->int->long->float->double
             ^
            char

*****************************************************************************************************************************************************
Operator
========
->Increment/Decrement operator
int a=5;
a=a+1;
OR
a=a++;

->a++: assign and increment 
  ++a: increment and assign

->Types of Operator
Arithmetic Operator:+ - * / %
Ex: 
-20%7=-6
10%30=10
10%-3=1

Relational Operator:> < >= <= == !=
 results Boolean value

Logical Operator: && || !
 Combines two or more relational operators


Shortcut Operator: & |

*****************************************************************************************************************************************************
Conditional Statements
======================
->if/if-else/if else-if else/ternary operator
->Condition can be simple relational operator or combination of Logical and relational operator
->Nested conditional are supported

if(condition)
{....}

if(condition)
{.....}
else
{.....}

if(condition)
{.....}
else if(condition)
{.....}
else
{......}

->Ternary operator
Syntax:
var = condition ? exp1 : exp2;
condition true, var=exp1 else var=exp2

Ex:
int a=(10>20)?10:20;
sop(a+" is big");

->exp can be another ternary operator

*****************************************************************************************************************************************************
Iterative Statements
====================
->for loop/while loop/do while loop

for(initialization; condition; increment or decrement)
{........}


initialization
while(condition)
{
......
increment or decrement
}


initialization
do
{
......
increment or decrement
}while(condition);

*****************************************************************************************************************************************************
Switch Statement
================
Syntax:
switch(exp)
{
case exp1:
statement;
break;

case exp1:
statement;
break;

default:
statement;

}

->exp can contains: byte, short, int, String
->exp1,2,3,.. should be constant or literals
->If we not add break then all below cases after satisfying condition will be executed.

Ex:
public class SwitchDemo {
    public static void main(String[] args) {
        int a = 40;

        switch (a) {
            case 10:
                System.out.println("Appu");
                break;

            case 20:
                System.out.println("Raghu");
                break;

            case 30:
                System.out.println("Shivu");
                break;

            default:
                System.out.println("Sharukh");
        }
    }
}

*****************************************************************************************************************************************************
Number system
=============
->Always output will be in decimal number format

->Octal
Prefix: O or o
Allowed: 0,1,...7

Ex:
int a=O45;
sop(a); //37

->Hexadecimal
Prefix: OX or ox
Allowed: 0,1,...9,A,B,C,D,E

Ex:
int a=OX45;
sop(a); //69

->Binary
Prefix: OB or ob
Allowed: 0,1

Ex:
int a=OB0100101;
sop(a); //37

*****************************************************************************************************************************************************
Naming Convention
=================
->Class, Interface, Enum names should start with uppercase and subsequent letter should starts with uppercase
->Package name should be lowercase
->Variables and Method names should be in Camel case.[start with small and subsequent letter should be in uppercase]
->Constant should be all in uppercase.
->No space allowed, can use _

*****************************************************************************************************************************************************
Class and Object
================
->Class is a Blueprint 
->Object is the instance of the Class
->reference variable contains reference value of the object and points to the created object.
->Creation of object is knows as Instantiation 

Class creation:
class className
{
constructors();
instance/static variables;
instance methods();
}

Object Creation:
className refVarName=new className();


->Exe flow
.java->COMPILER-->.class file-->JVM--->Output

Compile: Compiler during Compilation time
Execute: JVM during Runtime inside JRE

*****************************************************************************************************************************************************
JVM Memory
==========
->JVM exe inside JRE environment
->Method area/Stack area/Heap area/PC Register/Nature stack


new className();
->New memory will be created inside Heap area based on instance variable.
->Assign new value known as reference value for the object.
->Store Instance variable data, if not default value will be assigned.

Stack Area:
->When any method start to execute, stack trace for it will be created in stack area. Once it got executed, stack trace will be removed.
->Reference and Local variable will be stored in Stack area.
->Once stack trace is removed, local and reference variable will be removed.

Heap Area:
->Memory for the Object will be allocated from heap area and it contains Instance and Static variable data.
->When object do not have any reference variable then GC will remove it from the heap memory.

*****************************************************************************************************************************************************
Methods
=======
->Can be accessed by reference variable, class name or directly.

[accessModifiers] returnType methodName([parameters])
{
..........
[return value];
}

Note: When same method call itself finally we get StackOverflowError exception

*****************************************************************************************************************************************************
this keyword
============
->Used to refer current class instance member

*****************************************************************************************************************************************************
Scanner Class
=============
Scanner scanner=new Scanner(System.in);
String name=scanner.next();

*****************************************************************************************************************************************************
Object Oriented Programming Features
====================================
Class/Object/Encapsulation/Data hiding/Abstraction/Inheritance/Polymorphism

Polymorphism[Overloading]
-------------------------
->Method overloading and Method overriding

Method overloading
->2 or more methods in the class having same name and different parameter list[type or count].
->Which method to be called is decided at compile time itself. It is also knows as Compile time polymorphism.

Ex:
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

->It is not possible to create 2 method with same name and parameter list even if return type is different.

Ex: Not allowed
    float add(int a, int b)
    {
        return a+b;
    }

    int add(int a, int b)
    {
        return a+b;
    }

Encapsulation
-------------
->Make variable in the class as private and method as public.
->Binding variables and method together as single unit.
->Access variables through methods for increasing security.
->getter() used to get the value and setter() is used to set the value for the instance variables.

Ex:
class Demo1 {
    private int age;
    private String name;
    
    int displayAge() {
        return age;
    }
    String displayName() {
        return name;
    }
    void setAge(int age) {
        this.age = age;
    }
    void setName(String name) {
        this.name = name;
    }
}

*****************************************************************************************************************************************************
Constructor
===========
->Special method having name same as Class name, No return type, Invoke when object is created, Used to initialize the instance var data.
->Can have Access modifiers.
->On each Object creation Constructor is invoked.
->Constructor can be overloaded but cannot able to overrided.
->Works similar as setter(), can also do many task similar to methods.
->If dev has not added any constructor then by default , Compiler will add default 0 argument constructor.
->Types: Default[0 Argument] / User defined [0 argument and parameterized constructor] 
->Can add default, public, protected and private access modifiers

Ex:
class Demo2
{
    int age;
    String name;
    Demo2(String name,int age)
    {
        if(age>18)
        {
            this.age=age;
        }
        else {
            System.out.println("Invalid Age");
        }
        this.name=name;

    }
}
public class ConstructorDemo1 {
    public static void main(String[] args) {
        Demo2 d1=new Demo2("Appu",23);
        System.out.println(d1.age+" "+d1.name);
        Demo2 d2=new Demo2("Sivu",15);
        System.out.println(d2.age+" "+d2.name);
    }
}

OUTPUT:
23 Appu
Invalid Age
0 Sivu

->First statement of the constructor is super()
which will invoke parent class 0 argument constructor 
If we add this([parameter list]); manually then super() will not be there.
->First statement can be either this or super not both.
->Always parent class should have user defined or compiler defined 0 argument constructor, if all child class constructor don't have this() or super(param list)


Ex 1: Valid since parent have 0 argument constructor
class A
{
    A()
    {
        System.out.println("A 0 Arg Const");
    }

    A(int a)
    {
        System.out.println("A 1 Arg Const");
    }
}

class B extends A
{
    B()
    {
        System.out.println("B 0 Arg Const");
    }

    B(int a)
    {
        System.out.println("B 1 Arg Const");
    }
}
public class ConstructorSuper {
    public static void main(String[] args) {
        B b=new B(10);
    }
}

OUTPUT:
A 0 Arg Const
B 1 Arg Const
Flow: child 1 argument constructor>super() of child 1 argument constructor >parent 0 argument constructor>child 1 argument constructor 


Ex 2: In Valid, parent do not have 0 argument constructor 
class A
{
    A(int a)
    {
        System.out.println("A 1 Arg Const");
    }
}

class B extends A
{
    B()
    {
        System.out.println("B 0 Arg Const");
    }

    B(int a)
    {
        System.out.println("B 1 Arg Const");
    }
}
public class ConstructorSuper {
    public static void main(String[] args) {
        B b=new B(10);
    }
}

OUTPUT:
ERROR
Flow: child 1 argument constructor>super() of child 1 argument constructor >parent 0 argument constructor but its not available

->If any child class have constructor then parent must have 0 argument constructor else we need to add super(paramlist) in all child class constructor to avoid parent 0 argument constructor call from child class

Ex 3: Valid, Since we added manually super(param list) in all child class constructor
package basicstelusko;

class A {
    A() {
        System.out.println("A 0 Arg Const");
    }

    A(int a) {
        System.out.println("A 1 Arg Const");
    }
}

class B extends A {
    B() {
        super(10);
        System.out.println("B 0 Arg Const");
    }

    B(int a) {
        super(10);
        System.out.println("B 1 Arg Const");
    }
}

public class ConstructorSuper {
    public static void main(String[] args) {
        B b = new B(10);
    }
}


OUTPUT:
A 1 Arg Const
B 1 Arg Const

Constructor chaining
----------------------
One Constructor calls other Constructor of same class.
Case 1: 
>Within the class using this keyword
should be in first line inside the constructor.
this([parameter list])

>To call parent class constructor from child class constructor
>should be in first line inside the constructor.
super([parameter list])

Ex:
package basicstelusko;

class Demo3 {
    Demo3()
    {
        System.out.println("Demo3 Zero Arg Const");
    }

    Demo3(int a,int b,int c)
    {
        System.out.println("Demo3 three Arg Const");
    }
}
class Demo4 extends Demo3
{

    Demo4(int a)
    {
        System.out.println("Demo4 One Arg Const");
    }

    Demo4()
    {
        //this(10);
        super(1,2,3);
        System.out.println("Demo4 Zero Arg Const");
    }

    Demo4(int a,int b,int c)
    {
        System.out.println("Demo4 three Arg Const");
    }
}
public class ConstructorChaining {
    public static void main(String[] args) {
        Demo4 d=new Demo4();

    }
}

OUTPUT:
Demo3 three Arg Const
Demo4 Zero Arg Const

->Execution flow
Parent class constructor
Instance var/block
Child class constructor 

*****************************************************************************************************************************************************
Main method
===========
->We can overload main method but JVM consider the standard syntax main method for execution.
public class Demo {
    public static void main(String[] args) {
            }
}


*****************************************************************************************************************************************************
static keyword
==============
->Can be used with variables, block or to method
->Exe flow without parent class
static block or static variable
instance block or instance variable
constructor
instance block or instance variable
constructor

static block
------------
->
static 
{
....
}

*****************************************************************************************************************************************************
Inheritance
===========
->IS-A relation
->Re using exiting members[methods and variables] of the class instead of creating again.
->Parent Child relationship
->
parent/super/base
child/sub/derived

child class extends parent class
{
}

->Private property[var and method], constructor not participate in inheritance.

Types of methods in Inheritance
---------------------------------
Inherited methods: Method available in parent class and used without any modification in child class.
Overridden methods: Parent class method with new body in child class.
Specialized methods: Child class methods with its own body

Inheritance Types
-----------------
Single/Multi level/Multiple/Hierarchal
C extends A,B ->Not allowed due to Ambiguity issue

Constructor flow
----------------
object creation for child class>child class cons>super()>parent class 0 argument constructor>child class constructor

Always parent class 0 argument constructor will be invoked

this() vs super()
-----------------
To call constructor of same class we use this() and to call constructor of super class we use super()
Both should be inside first line of constructor only

Variable/method preference
--------------------------
local, class, super class

this vs super
-------------
this.varname: calls instance variable
super.varname: calls super class variable

When not to use Inheritance[HAS-A vs IS-A]
------------------------------------------
IS-A: Inheritance, if there exist is-a relation then use extends.
 
HAS-A: Composition, If there not exist is-a relation then else use has-a relation
       Create Object of that class and call those methods.

Ex 1: HAS-A relation
class Phone 
{
call(){...};
}

class Human
{
}

Human needs call() but not exist is-a relation so create Object and use

Solution:
class Human
{
Phone obj=new Phone();
obj.call();
}

Ex 2: HAS-A relation
class Bathtub
{
bath(){...};
}

class Home 
{
Bathtub obj=new Bathtub();
obj.bath(); //Since there not exist is-a relation we use has-a relation to access method
}

Ex 3: iPhone 14 extends iPhone 13
It has is-a relation so we can use extends

class iPhone13
{
playSong(){...};
}

class iPhone14 extends iPhone13
{
playSong(); //There exist is-a relation so use extends 
}

*****************************************************************************************************************************************************
Polymorphism[Overriding]
------------------------
->Same thing with different behaviour
->We can create super class reference and sub class Object
Parent p=new Child();
->Method of sub class overrides method of super class
Giving new functionality for the method of super class in child class
Runtime Polymorphism, In compile time compiler not aware of which method will be called either super or sub class method.
Create object for child class and reference for parent class, call the method.

Ex:
class Phone
{
    void call()
    {
        System.out.println("Calling");
    }
}

class Iphone extends  Phone
{
    void call()
    {
        System.out.println("Calling from Iphone");
    }
}
public class MethodOverridingDemo {

    public static void main(String[] args) {
        Phone obj=new Iphone();
        obj.call();
    }

}

OUTPUT:
Calling from iPhone

->
Allowed:
superclass reference =child class object();

Not Allowed:
sub class reference = super class object();

Rules for Method overriding
-----------------------------
->Cannot reduce Access modifiers power
->Method prototype[heading] should be same
->@Override annotation should be used
->private method cannot be overrided
->we cannot change return type for primitive data type, but if it has non primitive data type we can change but there should be parent child relationship between the return type of parent class return type and child class return type.

Co variant return type
parent class return type display()
{....}
child class return type display()
{...}

->Cannot change argument list

->Static method cannot not be override-method hiding[we get parent method body only not child]

Ex:
class Phone1
{
    static void call()
    {
        System.out.println("Calling");
    }
}

class Iphone1 extends  Phone1
{
    static void call()
    {
        System.out.println("Calling from Iphone");
    }
}

public class MethodHiding {

    public static void main(String[] args) {
        Phone1 obj=new Iphone1();
        obj.call();
    }
}

OUTPUT:
Calling

*****************************************************************************************************************************************************
Access Modifiers
================
->default/public/protected/private
->Can be applied to variable, constructor and methods

public: anywhere inside the project
Protected: within package and outside package with is-a relation
default: within package
private: within class

public>protected>default>private

*****************************************************************************************************************************************************
